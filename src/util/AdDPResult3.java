package util;

import org.apache.commons.math3.util.CombinatoricsUtils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.TreeMap;

/**
 * compute the final Ad from the Dynamic Programming result, which is generated by Ad.java
 */
public class AdDPResult3 {
    public static HashMap<TreeMap<String,Integer>,Double>[] F_Nd_;//F_Nd_[]=F_[Nd][]
    public static int[] listPhraseSize;
    public static int K;

    private static HashMap<Integer,Integer> turnListToMap(TreeMap<String,Integer> list){
        HashMap<Integer,Integer> dict=new HashMap<Integer, Integer>();
//        System.out.println(list);
        if(list.size()>0){
            int index=0;
            for(String key: list.keySet()){
                if(key.contains("_")){
                    int numNonEmpty=list.get(key);
                    String[] splitted=key.split("_");
                    int phraseSize=Integer.parseInt(splitted[0]);
                    int numTopicAssignedAsPhrase=Integer.parseInt(splitted[1]);
                    for(int i=0;i<numNonEmpty;i++){

                        for(int j=index;j<listPhraseSize.length;j++){
                            if(listPhraseSize[index]==phraseSize){
                                int phraseId=index;
                                dict.put(phraseId,numTopicAssignedAsPhrase);
                                index++;
                                break;
                            }else{
                                index++;
                            }
                        }

                    }
                }
            }
        }
        return dict;
    }

    /**
     * firstPart=\prod_{i=1}^{N^{(\mathcal{P})}_d} ({K\choose{1}} {|l(d,i)|\choose{m_i}} (K-1)^{|l(d,i)|-m_i})
     * secondPart=\exp(\sum_{i=1}^{N^{(\mathcal{P})}_d}\frac{m_i}{l(d,i)}  )
     * result=firstPart*secondPart
     * @param list
     * @return
     */
    private static double log_computeForList(TreeMap<String,Integer> list){
        double log_result=0;

        double log_firstPart=0;
        double exponentInSecondPart=0;

        HashMap<Integer,Integer> dict=turnListToMap(list);
        for(int i=0;i<listPhraseSize.length;i++){
            int numTopicAssignedAsPhrase=-1;
            if(dict.containsKey(i)){
                numTopicAssignedAsPhrase=dict.get(i);
            }else{
                numTopicAssignedAsPhrase=0;
            }
            log_firstPart=log_firstPart+Math.log(K)+Math.log(CombinatoricsUtils.binomialCoefficient(listPhraseSize[i],numTopicAssignedAsPhrase))
                        +Math.log(Math.pow(K-1,listPhraseSize[i]-numTopicAssignedAsPhrase));
            exponentInSecondPart=exponentInSecondPart+(double)numTopicAssignedAsPhrase/(double)listPhraseSize[i];
        }
        double log_secondPart=exponentInSecondPart;
        log_result=log_firstPart+log_secondPart;
        return log_result;
    }

    public static double getFinalResult(int _K,int[] _listPhraseSize,HashMap<TreeMap<String,Integer>,Double>[][] F_){
        K=_K;
        listPhraseSize=_listPhraseSize;

        F_Nd_=F_[listPhraseSize.length-1];

        double log_Ad=0;
        for(int x=0;x<F_Nd_.length;x++){
            for(TreeMap<String,Integer> list: F_Nd_[x].keySet()){
                double repetedTimes=F_Nd_[x].get(list);
                log_Ad=MathUtil.logSumExp(new double[]{log_Ad,log_computeForList(list)+Math.log(repetedTimes)});//TODO
            }
        }
        return log_Ad;
    }
}
